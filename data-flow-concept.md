#### 基本介绍
这篇文档是对程序分析课程学习的一个总结，选取了其中最感兴趣的指针分析作为切入点，先介绍了数据流分析的理论框架，然后对于use-def以及指针分析的数据流框架进行了说明，最后大致探讨了一下指针分析的代码实现框架，以及完成了一个比较小型的指针分析的llvm tool。通过本次作业不仅对于指针分析有了更深刻的了解，同时也对llvm上的IR操作有了进一步的了解。
#### 数据流分析基本概念
1. 基本定义：   
解决程序分析中的数据流流向的问题，可以通过数据流分析解决到达-定值问题，可用表达式  ，活跃变量等，数据流分析可以认为是经过CFG图上的基本块到其后继基本块时，其中感兴趣的变量的分析
2. 数据流分析理论框架：  
采用通用的框架俩计算所有的数据流问题，需要如下的信息
    1. 数据流传播的方向：前向数据流分析/后向数据流分析
    2. 计算的数据流信息属性：使用半格进行表示（semi-lattice)
    3. 传递函数：基本块怎么更新输入的数据流信息，例如加入新的数据流信息，删除已有的数据流信息
3. 基本介绍（semi-lattice）
    1. 基本概念：
        1. 半格是一个数学概念，可以理解成一个集合S，在这个集合上定义了一种叫做meet()的数学关系，这个数学算式使得集合中的元素a,b满足如下的关系，并且半格中具有上界以及下界
        ```math
        x \bigwedge x = x

        x \bigwedge y = y \bigwedge x
        
        x \bigwedge (y \bigwedge z) = (x \bigwedge y) \bigwedge z
        ```
        2. 在集合上定义一种偏序关系，满足偏序关系的集合中的元素满足如下的算式,偏序关系可以理解成集合中两个元素的大小关系的判定
        ```math
        x \leq x
        
        x \leq y, y \leq x  => x=y
        
        x\leq y , y\leq z => x\leq z
        ```
        3. 个人理解，集合中元素的偏序关系标识了这两个元素的大小以及对应的相关关系，所以要是x和y满足偏序关系，就认为x和y的meet操作可以计算.,meet可以简单的理解成取交集，此外，数据流分析的条件是半格的高度有限，高度有限才能经过一系列的传递函数到达最后的分析的不动点状态
        <!-- A = {{1,2},{1}}   {1}和{1，2}m满足偏序关系，两个可以比较大小，{1} meet{1,2} = {1}-->
    2. 传递函数：对于半格中的元素，通过传递函数能从a状态到达b状态，将半格中的元素操作函数中的操作数，计算从当前的状态到达下一状态
        1. 传递函数具有单调有限性以及termination:
            1. 单调有限性：本格的高度是有限的，意思是最终数据流分析会收敛，并且在半格中经过迭代之后，计算出来的对象具有偏序关系，
        2. 传递函数具有分布性：
        ```math
        f(x \bigwedge y) = f(x) \bigwedge f(y)
        ```
    3. 数据流分析的解的精确性：
        1. MOP: 计算每条路径上的数据流的解，然后最后将结果进行meet操作
        2. MFP: 在路径交汇的时候进行meet操作，然后再通过传递函数进行计算
4. 真正的数据流分析：
    1) 首先将稍微简单一点到达定值作为例子说明数据分析框架
        1. 到达定值的定义：对于变量x的一个定义语句s可以到达程序点P如果存在路径从定义语句s后的程序点到P，并且这个路径上没有对于x的重新定义
        2. 数据流框架的具体实现:
            1. 对应的传递函数：每一个语句块结束之后，此处的到达定值应该这个语句中新定义的变量x加上入口的S-在这个语句中被重新定义的变量：  
            F: out[B] = (in[B]/e_kill[B])并上e_gen(B)
            2. 对应的S集合应该是程序中所有定义出来的变量能产生的各个子集合，比方说定义了A,B, 对应的S集合应该是{A, B, {A, B}}, S集合可以理解成传递函数所需要的值域以及定义域
            3. meet：集合的并 
    2) 指针分析：
        1. 指向集分析，分析指针P对应的指向集，这种分析是一种可能性分析，所以应该注意的是，当增加新的可能性之后，应该做的操作是并操作而不是交集操作
            1. 对应的数据流分析的框架：
                1. S: 程序中的变量x可能对应的指向集的集合
                2. 传递函数：针对不同的指针变量采用不同的指针传递方式
                3. 对应的meet操作：因为指针分析是一个可能性分析，所以对应的meet操作应该是集合的并集
        2. 指针分析包含过程内分析以及过程间分析：
        3. 指针分析中的Andersen算法/Steensgaard算法：指针分析个人理解应该是指向集的更迭的分析，指针对象的指向集一直发生改变，直到达到最后的不动点
            1. andersen算法:
            ```
            base： a = &b  b包含在a的指向集中间pts(a)中有b
            assign: a = b a和b目前指向同样的指向集，并且都是b的指向集，这种看法是主管理解上的看法，在程序分析中应该将=理解成包含关系，比方说a的指向集是{c,d},b的指向集是{e},那么更新之后，a对应的指向集会变成{c.d.e}
            store: *p = b 相当于把b存放到p对应的内存中间，所以应该对应于p中每个指向集元素a，都有b被包含在a对应的指向集中
            load: a = *q 相当于对于q的指向集中的每一个元素p，都有 a = p的关系
            ```
            2. steensgaard算法比anderson算法的精确度低，两种算法在指针的处理方式上基本一致，中间有一个区别是它不考虑指向集的传递，在进行运算的时候，直接是相等操作。所以这种算法的精确程度差一点，但是效率更高
            ```
            assign：a = b -> pts(b) = pts(a)
            ```
        4. 其余相关知识点：
            1. 流敏感分析：流敏感和分支相关
            2. 域敏感分析：一个struct对象是不是当作一个整体，一个struct对象要是作为一个整体就认为是域非敏感的分析，因为域中可能包含指针，所以为了精确的进行指针分析，需要进行域分析
#### 指针分析的代码实现思路
5. 通过llvm实现简单指针分析的思路：
    1. 实现指针分析应该是在ir上增加分析的pass，此处复习一下编译的基本知识，编译分为如下几个阶段：词法分析（AST阶段）-> 语法分析（检查基本的代码中问题）-> 语义分析(三地址码) -> 中间代码优化(在ir上加上pass进行分析) -> 代码生成(属于编译过程中的后端，其中按照不同的架构将代码转化为不同的指令集)
    2. 目前思考的指针分析的代码思路是在llvm上增加两个pass：
        1. pass1：实现指针分析的数据流分析框架，通过分析程序中的每一条指令，来确定其中指针对应的指向集，利用anderson算法对于指向集进行更新，最后达到分析的不动点，并且需要存储本次的数据流分析的结果
        2. pass2：本次pass实现的是一个use-def的分析，解析出来函数指针，然后通过输出指针对应的指向集

#### 编程过程中的一些问题总结：
1. 源代码编译到IR上指令：
    1. 编译为bc文件：clang -emit-llvm -c -O0 -g3 source.c
    2. 编译成ll文件：可读的IR文件：clang -emit-llvm -S -O0 -g3 source.c
2. 具体的例子进行分析测试：
```
#include <stdlib.h>

int plus(int a, int b) {
   return a+b;
}

int minus(int a,int b)
{
    return a-b;
}

int foo(int a,int b,int(* a_fptr)(int, int))
{
    14： return a_fptr(a,b);
}


int moo(char x)
{
    int (*af_ptr)(int ,int ,int(*)(int, int))=foo;
    int (*pf_ptr)(int,int)=0;
    if(x == '+'){
        pf_ptr=plus;
24:     af_ptr(1,2,pf_ptr);
        pf_ptr=minus;
    }
27: af_ptr(1,2,pf_ptr);
    return 0;
}
这个程序中对应的指针的情况：
第一步：分析程序，找到指针对应的指向集：
1. 其中第14行是一个函数指针，需要分析其可能对应的指向关系，可能存在的指向关系有两个。进入分支中之后先被赋值为plus，所以pts(pf_ptr) = {plus}，然后是被赋值minus, 按照anderson算法，pts(pf_ptr) = {plus, minus}。
2. 因为af_ptr直接是只有一次赋值，所以对应的指向集就是foo，因此出现对于af_ptr的时候，就直接给出来foo。
第二步：利用程序的use-def关系，找到程序中的调用位置调的是哪一个函数指针：
%0 = load i32 (i32, i32)*, i32 (i32, i32)** %a_fptr.addr, align 8
%1 = load i32, i32* %a.addr, align 4
%2 = load i32, i32* %b.addr, align 4
%call = call i32 %0(i32 %1, i32 %2)
从程序可以看出来，可以在ir中首先分析出来callinst，，然后通过getcaller的方式再加上使用use-def就能确定此处函数指针的指向
```


#### 程序测试效果展示：
1. 以上面的函数为例，通过运行编译出来的llvm tool可以实现准确分析函数指针对应的值
```
summer@ubuntu:~/Desktop/compile_test/test_case$ ./llvmassignment test00.bc
14 : minus, plus
24 : foo
27 : foo
```


#### 程序的不足之处
1. 程序应该算是流非敏感分析, 因为是直接计算出来了指向集，然后在对应的函数调用位置直接输出指向集，目前对于流敏感的指针分析还不太会，后续可以再学习一下

#### 数据流分析框架的代码实现
1. 定义了一堆数据结构
    1. LivenessInfo

<!--test-->
    

